![](Media/Study.jpeg)

# :closed_book: `Estudo sobre a linguagem C#`
* Di√°rio de bordo realizado para a mat√©ria de Linguagens e Paradigmas de Programa√ß√£o;
* A linguagem escolhida foi C#;
* Os t√≥picos abordados nesse estudo foram retirados dos slides das aulas, as quais tamb√©m serviram como base para o estudo.

## üñ• O que √© uma linguagem de programa√ß√£o?

* Uma linguagem de programa√ß√£o √© um conjunto de regras e s√≠mbolos usados para escrever programas de computador. √â uma forma padronizada de comunica√ß√£o entre humanos e computadores, permitindo que os programadores expressem suas instru√ß√µes de forma estruturada e compreens√≠vel para a m√°quina;

* As linguagens de programa√ß√£o s√£o usadas para desenvolver uma ampla variedade de software, desde aplicativos simples at√© sistemas complexos. Elas fornecem um conjunto de comandos e estruturas de controle que permitem aos programadores criar algoritmos e instru√ß√µes que ser√£o executadas pelo computador;

* Existem muitas linguagens de programa√ß√£o diferentes, cada uma com suas pr√≥prias regras sint√°ticas e sem√¢nticas. Algumas das linguagens mais populares incluem C, C++, Java, Python, JavaScript e Ruby. Cada linguagem tem suas pr√≥prias caracter√≠sticas e finalidades espec√≠ficas, e a escolha da linguagem depende do tipo de aplicativo ou sistema que est√° sendo desenvolvido, bem como das prefer√™ncias do programador.

## :globe_with_meridians: √Åreas de atua√ß√£o da linguagem

*   **Desenvolvimento de software para Windows:** C# √© uma das principais linguagens usadas para desenvolver aplicativos e sistemas para a plataforma Windows. O framework .NET, que inclui o ambiente de execu√ß√£o e bibliotecas, √© amplamente utilizado para criar aplicativos desktop, servi√ßos web e outros tipos de software para Windows;

*   **Desenvolvimento de aplicativos m√≥veis:** Com a introdu√ß√£o do Xamarin, uma plataforma de desenvolvimento multiplataforma, √© poss√≠vel desenvolver aplicativos m√≥veis nativos para iOS e Android usando C# e o framework .NET. O Xamarin permite compartilhar grande parte do c√≥digo entre as plataformas, tornando o desenvolvimento mais eficiente;

*   **Desenvolvimento de jogos:** C# √© uma linguagem muito popular para o desenvolvimento de jogos, especialmente para a plataforma Unity. O Unity √© um motor de jogos amplamente utilizado e suporta a programa√ß√£o em C#. Muitos jogos populares foram desenvolvidos usando C# e Unity;

*   **Desenvolvimento de aplica√ß√µes web:** Embora outras linguagens, como JavaScript e Python, sejam mais comumente usadas para o desenvolvimento web, C# tamb√©m √© usado nessa √°rea. O framework ASP.NET permite criar aplicativos web robustos e escal√°veis usando C#. Al√©m disso, o ASP.NET Core, uma vers√£o mais recente do framework, suporta o desenvolvimento web multiplataforma;

*   **Desenvolvimento de aplica√ß√µes empresariais:** C# √© frequentemente usado no desenvolvimento de aplica√ß√µes empresariais devido √† sua robustez, desempenho e integra√ß√£o com o ambiente Windows. Muitos sistemas de gerenciamento de conte√∫do (CMS), sistemas de gerenciamento de relacionamento com o cliente (CRM) e aplicativos de neg√≥cios s√£o desenvolvidos em C#.

## :clipboard: Crit√©rios de Avalia√ß√£o

* **Legibilidade:** A legibilidade de uma linguagem de programa√ß√£o refere-se √† facilidade de leitura do c√≥digo fonte. O C# √© conhecido por sua sintaxe clara e bem estruturada, o que facilita a compreens√£o e o acompanhamento do fluxo de l√≥gica. Alguns aspectos que contribuem para a legibilidade s√£o:

  * **Uso de palavras-chave intuitivas:** utiliza palavras-chave que s√£o facilmente compreendidas pelos programadores, tornando o c√≥digo mais expressivo e claro;

  * **Blocos de c√≥digo bem definidos:** usa chaves {} para delimitar blocos de c√≥digo, tornando mais f√°cil identificar o escopo das instru√ß√µes;

  * **Identa√ß√£o consistente:** a linguagem incentiva o uso consistente de espa√ßamento e indenta√ß√£o para melhorar a legibilidade;

  * **Nomes de vari√°veis descritivos:** a pr√°tica de dar nomes descritivos para vari√°veis e fun√ß√µes √© incentivada, tornando o prop√≥sito das entidades do programa mais claro.

* **Redigibilidade:** A redigibilidade refere-se √† facilidade com que um programador pode escrever c√≥digo limpo e funcional. O C# oferece recursos que tornam a tarefa de desenvolvimento mais agrad√°vel e eficiente. Alguns aspectos que melhoram a redigibilidade s√£o:

  * **Biblioteca padr√£o rica:** possui uma biblioteca padr√£o extensa, que fornece muitas estruturas de dados e fun√ß√µes √∫teis, evitando que os desenvolvedores tenham que reinventar a roda ao criar aplicativos;

  * **OOP (Programa√ß√£o Orientada a Objetos):** suporta totalmente conceitos de OOP, como classes, heran√ßa, polimorfismo e encapsulamento, tornando a estrutura√ß√£o do c√≥digo mais organizada e reutiliz√°vel;

  * **Generics:** a utiliza√ß√£o de tipos gen√©ricos permite criar algoritmos e estruturas de dados que podem ser reutilizados com diferentes tipos, aumentando a efici√™ncia da reda√ß√£o do c√≥digo;

  * **Sintaxe amig√°vel:** a linguagem possui uma sintaxe clara e natural, permitindo expressar ideias de forma concisa.

* **Confiabilidade:** A confiabilidade de uma linguagem de programa√ß√£o est√° diretamente relacionada √† previsibilidade e seguran√ßa do c√≥digo gerado. O C# tem algumas caracter√≠sticas que o tornam uma linguagem confi√°vel:

  * **Tipagem est√°tica:** √© uma linguagem com tipagem est√°tica, o que significa que os tipos de dados das vari√°veis s√£o verificados em tempo de compila√ß√£o. Isso ajuda a capturar erros de tipo antes que o programa seja executado, tornando-o mais seguro;

  * **Gerenciamento de mem√≥ria:** usa o Common Language Runtime (CLR) para gerenciar a mem√≥ria, o que inclui coleta autom√°tica de lixo (garbage collection), ajudando a evitar vazamentos de mem√≥ria e erros relacionados;

  * **Tratamento de exce√ß√µes:** oferece um mecanismo de tratamento de exce√ß√µes robusto, permitindo que os programadores capturem e lidem com erros de forma mais eficiente, melhorando a estabilidade dos programas;

  * **Programa√ß√£o ass√≠ncrona:** possui suporte nativo para programa√ß√£o ass√≠ncrona, o que facilita a cria√ß√£o de aplicativos que s√£o mais responsivos e escal√°veis.

## :interrobang: Categorias da Linguagem

* C# √© principalmente uma linguagem de programa√ß√£o imperativa e orientada a objetos. No entanto, a partir da vers√£o C# 3.0, ela tamb√©m incorporou recursos do paradigma funcional, permitindo que os desenvolvedores usem conceitos funcionais em suas abordagens de programa√ß√£o.

* Vamos detalhar cada aspecto:

  * **Imperativa:** Em C#, os programas s√£o escritos como uma sequ√™ncia de instru√ß√µes que especificam como as tarefas devem ser executadas. Os desenvolvedores usam estruturas de controle, como loops e condicionais, para definir o fluxo do programa;

  * **Orientada a objetos:** C# √© uma linguagem fortemente orientada a objetos, o que significa que os programas s√£o estruturados em torno de classes e objetos. Os objetos s√£o inst√¢ncias de classes que cont√™m dados e comportamentos relacionados, permitindo uma modelagem mais organizada e modular do software;

  * **Funcional:** A partir da vers√£o C# 3.0, a linguagem incorporou recursos do paradigma funcional, como fun√ß√µes de alta ordem, express√µes lambda, delegados e LINQ (Language-Integrated Query). Isso permite que os desenvolvedores adotem uma abordagem mais funcional em certas partes do c√≥digo, enfatizando a imutabilidade de dados e a avalia√ß√£o de fun√ß√µes.

##  :inbox_tray: M√©todos de Implementa√ß√£o

* A linguagem C# √© implementada atrav√©s de um compilador e de uma m√°quina virtual.

  * **Compilador:** O compilador de C# √© respons√°vel por transformar o c√≥digo-fonte escrito em C# em c√≥digo intermedi√°rio, conhecido como CIL (Common Intermediate Language) ou IL (Intermediate Language). O compilador C# converte o c√≥digo-fonte em CIL, garantindo que ele siga a sintaxe e sem√¢ntica da linguagem. O resultado √© um arquivo com extens√£o .dll (biblioteca din√¢mica) ou .exe (execut√°vel) contendo o c√≥digo intermedi√°rio;

  * **M√°quina virtual:** O c√≥digo intermedi√°rio (CIL) √© executado na m√°quina virtual da plataforma .NET, chamada CLR (Common Language Runtime). O CLR √© respons√°vel por carregar e executar o c√≥digo intermedi√°rio gerado pelo compilador C#. Ele fornece v√°rias funcionalidades, como gerenciamento de mem√≥ria, coleta de lixo, seguran√ßa e verifica√ß√£o de tipos, garantindo que o c√≥digo seja executado de forma segura e eficiente em diferentes ambientes de sistema operacional.

* Portanto, o processo de implementa√ß√£o da linguagem C# envolve o uso do compilador C# para gerar c√≥digo intermedi√°rio (CIL) e a execu√ß√£o desse c√≥digo no ambiente da m√°quina virtual CLR da plataforma .NET. Isso permite que os programas escritos em C# sejam executados em diferentes sistemas operacionais que suportem o CLR, tornando a linguagem port√°til e multiplataforma.

______________________

<p align="center">
  <img width="720" height="227" src="Media/Logo.png">
</p>

##  :1234: Atributos das Vari√°veis

* **Nome:**

  * Forma:

    * Os nomes de vari√°veis em C# podem ser compostos por letras, d√≠gitos num√©ricos e caracteres de sublinhado (underscore "_");
    * O nome deve come√ßar com uma letra (a-z, A-Z) ou um caractere de sublinhado ("_");
    * N√£o √© permitido come√ßar um nome com um d√≠gito num√©rico.

  * Tamanho:

    * O tamanho m√°ximo de um nome de vari√°vel em C# √© ilimitado. No entanto, √© uma boa pr√°tica manter os nomes de vari√°veis razoavelmente curtos e descritivos para facilitar a legibilidade do c√≥digo.

  * Caracteres de conex√£o:

    * Sim, caracteres de sublinhado ("_") podem ser usados em nomes de vari√°veis. Por exemplo, "minha_variavel" √© um nome de vari√°vel v√°lido em C#.

  * Distin√ß√£o :

    * Sim, C# √© uma linguagem case sensitive, ou seja, faz distin√ß√£o entre mai√∫sculas e min√∫sculas nos nomes de vari√°veis. Isso significa que as letras mai√∫sculas e min√∫sculas s√£o tratadas como caracteres diferentes. Por exemplo, "minha_variavel" e "Minha_Variavel" s√£o considerados nomes de vari√°veis distintos.

  * Palavras reservadas:

    * A linguagem C# reserva setenta e cinco palavras para seu pr√≥prio uso. Estas palavras s√£o chamadas de palavras reservadas e cada uma tem um uso particular. Palavras reservadas n√£o s√£o permitidas como nome de vari√°veis.

    * Segue uma lista que identifica todas estas palavras:

      | abstract | as       | base    | Bool     |
      | ----------- | ----------- | ----------- | ----------- |
      | break    | byte     | case    | Catch    |
      | char     | checked  | class   | Const    |
      | continue | decimal  | default | Delegate |
      | do       | double   | else    | Enum     |
      | event    | explicit | extern  | false    |
      | finally  | fixed    | float   | for      |
      | foreach  | goto     | if      | implicit |
      | in       | int      | interface | internal |
      | is       | lock     | long    | namespace|
      | new      | null     | object  | operator |
      | out      | override | params  | private  |
      | protected| public   | readonly| ref      |
      | return   | sbyte    | sealed  | short    |
      | sizeof   | stackalloc | static | string   |
      | struct   | switch   | this    | throw    |

* **Tipos e seus intervalos de valores:**

  |Tipo | Valor |
  | ----------- | ----------- |
  |bool | Verdadeiro ou Falso (Valores booleanos) |
  |byte | 0 a 255 (8 bits) |
  |sbyte | -128 a 127 (8 bits) |
  |char | Um caractere (16 bits) |
  |decimal | ¬±1.0 √ó 10‚àí28 a ¬±7.9 √ó 1028 (128 bits) |
  |double | ¬±5.0 √ó 10‚àí324 a ¬±1.7 √ó 10308 (64 bits) |
  |float | ¬±1.5 √ó 10‚àí45 a ¬±3.4 √ó 1038 (32 bits) |
  |int | -2,147,483,648 a 2,147,483,647 (32 bits) |
  |uint | 0 a 4,294,967,295 (32 bits) |
  |long | ‚Äì9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 (64 bits) |
  |ulong | 0 a 18,446,744,073,709,551,615 (64 bits) |
  |object | Qualquer tipo |
  |short | -32,768 a 32,767 (16 bits) |
  |ushort | 0 a 65,535 (16 bits) |
  |string | Sequ√™ncia de caracteres (16 bits por caractere) |

  * Exemplo das vari√°veis em forma de c√≥digo:

    ```csharp
    using System;

    class Program
    {
        static void Main()
        {
            // Declara√ß√£o e inicializa√ß√£o de vari√°veis
            bool isTrue = true;
            bool isFalse = false;
            byte myByte = 200;
            sbyte mySByte = -50;
            char myChar = 'A';
            decimal myDecimal = 1234.56789M;
            double myDouble = 3.141592653589793;
            float myFloat = 2.718281828459045f;
            int myInt = 42;
            uint myUInt = 4294967295;
            long myLong = 9223372036854775807;
            ulong myULong = 18446744073709551615;
            object myObject = "Qualquer tipo pode ser armazenado aqui.";
            short myShort = -1000;
            ushort myUShort = 5000;
            string myString = "Exemplo de sequ√™ncia de caracteres.";
        }
    }
    ```
* **Amarra√ß√£o de tipo:**

  * Est√°tica

    * O tipo de amarra√ß√£o (binding) das vari√°veis √© est√°tico. Isso significa que o tipo de uma vari√°vel √© definido em tempo de compila√ß√£o e n√£o pode ser alterado durante a execu√ß√£o do programa. Quando voc√™ declara uma vari√°vel, precisa especificar explicitamente o tipo dela.

      ```csharp
      //Exemplo de amarra√ß√£o est√°tica
      int idade = 25;
      string nome = "Jo√£o";
      ```
  
  * Infer√™ncia

    * C# tamb√©m suporta o recurso de infer√™ncia de tipo, introduzido na vers√£o 3.0 atrav√©s do recurso "var". Com a infer√™ncia de tipo, o compilador √© capaz de deduzir automaticamente o tipo da vari√°vel com base no valor atribu√≠do a ela.

      ```csharp
      //Exemplo de infer√™ncia
      var numero = 42; // O compilador infere que "numero" √© do tipo int.
      var texto = "Hello, world!"; // O compilador infere que "texto" √© do tipo string.
      ```
    * Apesar do uso de "var", √© importante notar que o tipo da vari√°vel √© definido em tempo de compila√ß√£o, e n√£o h√° mudan√ßa na natureza est√°tica. A infer√™ncia de tipo √© apenas uma forma de escrever o c√≥digo de forma mais concisa, sem perder a tipagem est√°tica da linguagem.

  * Din√¢mica

    * Em C# existe a possibilidade de utilizar amarra√ß√£o din√¢mica de tipos atrav√©s do tipo especial "dynamic". O tipo "dynamic" foi introduzido na vers√£o 4.0 da linguagem e permite que voc√™ defina vari√°veis cujos tipos s√£o resolvidos em tempo de execu√ß√£o, em vez de serem definidos em tempo de compila√ß√£o.

    * Quando voc√™ declara uma vari√°vel com o tipo "dynamic", o compilador n√£o faz a verifica√ß√£o de tipo em tempo de compila√ß√£o. Isso significa que voc√™ pode realizar opera√ß√µes em vari√°veis "dynamic" sem que o compilador verifique se essas opera√ß√µes s√£o v√°lidas para o tipo atribu√≠do a ela. Em vez disso, essas verifica√ß√µes s√£o feitas em tempo de execu√ß√£o.

      ```csharp
      dynamic valor = 10;
      Console.WriteLine(valor); // Sa√≠da: 10

      valor = "Ol√°";
      Console.WriteLine(valor); // Sa√≠da: Ol√°

      valor = DateTime.Now;
      Console.WriteLine(valor); // Sa√≠da: A data e hora atual

      valor = 3 + 4;
      Console.WriteLine(valor); // Sa√≠da: 7
      ```

    * Observe que o tipo da vari√°vel "valor" √© definido dinamicamente conforme o valor que √© atribu√≠do a ela. No primeiro caso, o tipo √© inferido como int, no segundo caso, como string e assim por diante.

    * √â importante ter cuidado ao usar "dynamic", pois voc√™ perde as verifica√ß√µes de tipo em tempo de compila√ß√£o, o que pode levar a erros em tempo de execu√ß√£o se as opera√ß√µes n√£o forem compat√≠veis com o tipo real da vari√°vel. A utiliza√ß√£o de "dynamic" √© recomendada apenas em situa√ß√µes espec√≠ficas em que √© realmente necess√°rio lidar com tipos desconhecidos ou em interopera√ß√£o com APIs din√¢micas, como COM ou linguagens din√¢micas. Em geral, √© prefer√≠vel utilizar a tipagem est√°tica para obter maior seguran√ßa e desempenho.

* **Escopo:**

  * Em C#, o tempo de vida de uma vari√°vel depende do escopo em que ela √© declarada. Existem tr√™s principais escopos em que as vari√°veis podem ser declaradas:

    * **Escopo de bloco (local):** Vari√°veis declaradas dentro de um bloco de c√≥digo, como dentro de um m√©todo, t√™m tempo de vida restrito ao bloco em que foram declaradas. Quando o bloco √© conclu√≠do, a vari√°vel √© destru√≠da e a mem√≥ria que ocupava √© liberada. Isso √© conhecido como "vari√°vel local".

      ```csharp
      public void ExemploMetodo()
      {
          int variavelLocal = 10; // vari√°vel local
          // outras opera√ß√µes com variavelLocal
      } // variavelLocal ser√° destru√≠da ap√≥s a conclus√£o do m√©todo
      ```
    
    * **Escopo de classe (campo):** Vari√°veis declaradas em n√≠vel de classe t√™m tempo de vida igual ao tempo de vida da inst√¢ncia da classe. Elas existem enquanto o objeto da classe existe e s√£o destru√≠das quando o objeto √© liberado da mem√≥ria.

      ```csharp
      public class MinhaClasse
      {
          private int campo = 20; // vari√°vel de classe (campo)
          // outras opera√ß√µes com campo
      } // campo ser√° destru√≠da quando a inst√¢ncia de MinhaClasse for liberada da mem√≥ria
      ```

    * **Escopo est√°tico (vari√°veis est√°ticas):** Vari√°veis declaradas como "static" t√™m tempo de vida igual ao tempo de vida do programa. Elas s√£o criadas quando o programa come√ßa sua execu√ß√£o e s√≥ s√£o destru√≠das quando o programa termina.

      ```csharp
      public class MinhaClasse
      {
          private static int variavelEstatica = 30; // vari√°vel est√°tica
          // outras opera√ß√µes com variavelEstatica
      } // variavelEstatica ser√° destru√≠da quando o programa terminar
      ```

* **Ambiente de refer√™ncia√ß√£o:**

  * Ambiente de referencia√ß√£o de uma senten√ßa √© o conjunto de todas as vari√°veis vis√≠veis naquela posi√ß√£o. Em uma linguagem de escopo est√°tico (que √© o caso da nossa linguagem C#) s√£o as vari√°veis declaradas em seu escopo local, mais o conjunto de todas as vari√°veis de seus escopos ancestrais vis√≠veis.

* **Constantes:**

  * Em C# existem constantes nomeadas, que s√£o valores fixos que n√£o podem ser alterados durante a execu√ß√£o do programa. Em vez de usar valores literais diretamente no c√≥digo, as constantes nomeadas permitem atribuir um nome significativo a um valor constante, tornando o c√≥digo mais leg√≠vel e facilitando a manuten√ß√£o.

  * Para definir uma constante nomeada em C#, voc√™ pode usar a palavra-chave const ou readonly.

  * Constantes com a palavra-chave const:

    ```csharp
    public class MinhaClasse
    {
        // Constante nomeada usando a palavra-chave 'const'
        public const int MinhaConstante = 42;

        // Outros membros da classe
    }
    ```
    * Neste exemplo, MinhaConstante √© uma constante nomeada que foi atribu√≠da ao valor inteiro 42. O valor de uma constante definida com const √© avaliado em tempo de compila√ß√£o, e a constante √© considerada uma constante literal. Isso significa que o valor deve ser conhecido em tempo de compila√ß√£o e deve ser um tipo de dado primitivo ou uma string.

  * Constantes com a palavra-chave readonly:

    ```csharp
    public class MinhaClasse
    {
        // Constante nomeada usando a palavra-chave 'readonly'
        public static readonly int MinhaConstante = 100;

        // Outros membros da classe
    }
    ```
    * Neste caso, MinhaConstante √© uma constante nomeada definida com a palavra-chave readonly. O valor de uma constante readonly √© avaliado em tempo de execu√ß√£o, o que significa que ele pode ser atribu√≠do durante a inicializa√ß√£o da vari√°vel ou em um construtor, permitindo a inicializa√ß√£o com base em l√≥gica mais complexa.

  * Uma diferen√ßa importante entre const e readonly √© que as constantes readonly podem ser usadas em classes e estruturas, enquanto as constantes const s√£o restritas a tipos primitivos ou strings e s√≥ podem ser usadas em n√≠vel de classe.

  * Independente da palavra-chave utilizada, as constantes nomeadas em C# s√£o uma maneira eficaz de tornar o c√≥digo mais leg√≠vel, manuten√≠vel e de evitar erros ao usar valores constantes em v√°rias partes do programa.

##  :game_die: Tipos de Dados

  * **Tipos primitivos:** 

    * Os tipos de dados primitivos, tamb√©m conhecidos como tipos de valor, s√£o usados para armazenar valores individuais. Esses tipos s√£o fornecidos pela linguagem e n√£o requerem inst√¢ncia de objetos. Os tipos de dados primitivos incluem:

      * Tipos Num√©ricos Inteiros:
        *  **int:** Representa n√∫meros inteiros com sinal de 32 bits/ 4 bytes;
        *  **uint:** Representa n√∫meros inteiros sem sinal de 32 bits/ 4 bytes;
        *  **short:** Representa n√∫meros inteiros com sinal de 16 bits/ 2 bytes;
        *  **ushort:** Representa n√∫meros inteiros sem sinal de 16 bits/ 2 bytes;
        *  **long:** Representa n√∫meros inteiros com sinal de 64 bits/ 8 bytes;
        *  **ulong:** Representa n√∫meros inteiros sem sinal de 64 bits/ 8 bytes;
        *  **byte:** Representa n√∫meros inteiros sem sinal de 8 bits/ 1 byte;
        *  **sbyte:** Representa n√∫meros inteiros com sinal de 8 bits/ 1 byte.

      * Tipos Num√©ricos de Ponto Flutuante:
        *  **float:** Representa n√∫meros de ponto flutuante de precis√£o simples de 32 bits/ 4 bytes;
        *  **double:** Representa n√∫meros de ponto flutuante de precis√£o dupla de 64 bits/ 8 bytes;
        *  **decimal:** Representa n√∫meros de ponto flutuante de alta precis√£o de 128 bits/ 16 bytes.

      * Tipo Char:
        *  **char:** Representa um √∫nico caractere Unicode de 16 bits/ 2 bytes.

      * Tipo Booleano:
        * **bool:** Representa um valor verdadeiro ou falso (true ou false).

  * **Tipos n√£o primitivos:**

    * Os tipos de dados n√£o primitivos, tamb√©m conhecidos como tipos de refer√™ncia, s√£o usados para armazenar refer√™ncias a objetos. Eles exigem uma inst√¢ncia de objeto para serem utilizados e s√£o armazenados na mem√≥ria gerenciada. Os tipos de dados n√£o primitivos incluem:

      *  **string:** Representa uma sequ√™ncia de caracteres Unicode. √â usado para armazenar e manipular texto.

      *  **object:** √â a classe base de todos os tipos em C#. Pode armazenar qualquer valor de qualquer tipo e √© comumente usado quando a especifica√ß√£o exata do tipo √© desconhecida ou n√£o √© relevante.

      *  **Array:** Representa uma cole√ß√£o fixa de elementos do mesmo tipo. Os arrays podem ser unidimensionais, multidimensionais ou jagged (arrays de arrays).

      *  **Classe (class):** √â um tipo de refer√™ncia personalizado definido pelo programador. Uma classe √© uma estrutura de dados que encapsula dados e comportamentos relacionados.

      *  **Interface (interface):** √â uma refer√™ncia a um contrato que define um conjunto de m√©todos que uma classe deve implementar. As interfaces permitem a implementa√ß√£o de m√∫ltiplas interfaces por uma classe.

      *  **Delegate (delegado):** Representa uma refer√™ncia a um m√©todo, permitindo tratar m√©todos como entidades que podem ser passadas como par√¢metros e invocadas.

      *  **Enumera√ß√£o (enum):** √â um tipo de valor que consiste em um conjunto de constantes nomeadas, representando valores simb√≥licos associados a um tipo de dados integral.

      *  **Struct (struct):** √â um tipo de valor personalizado, semelhante a uma classe, mas geralmente usado para tipos de valor mais simples e leves.

      *  **Nullable (Tipos Nullable):** Permitem que tipos de valor aceitem valores nulos al√©m de seus valores normais. Por exemplo, int? √© usado para um inteiro que pode ser nulo.

  * **Tipos ordinais:**

    * Os tipos ordinais (tamb√©m conhecidos como enums) definidos pelo usu√°rio s√£o tipos enumerados personalizados que permitem definir um conjunto nomeado de constantes com valores associados. Eles s√£o √∫teis para representar conjuntos discretos de valores, como dias da semana, estados, op√ß√µes, etc.

    * Para criar um tipo ordinal definido pelo usu√°rio (enum) em C#, voc√™ pode usar a palavra-chave enum. Aqui est√° um exemplo de como definir um tipo enum para representar os dias da semana:

      ```csharp
      public enum DiaDaSemana
      {
        Domingo,
        Segunda,
        Terca,
        Quarta,
        Quinta,
        Sexta,
        Sabado
      }
      ```

      * Neste exemplo, definimos um tipo enum chamado DiaDaSemana e listamos os dias da semana como constantes nomeadas. Por padr√£o, os valores associados come√ßam a partir de 0 (Domingo = 0, Segunda = 1, Ter√ßa = 2, etc.), mas voc√™ pode atribuir valores espec√≠ficos se necess√°rio.

    * Exemplo com valores espec√≠ficos:

      ```csharp
      public enum DiaDaSemana
      {
        Domingo = 1,
        Segunda = 2,
        Terca = 3,
        Quarta = 4,
        Quinta = 5,
        Sexta = 6,
        Sabado = 7
      }
      ```

       * Aqui, atribu√≠mos explicitamente valores num√©ricos aos dias da semana, come√ßando por 1.

    * Com a defini√ß√£o do enum, podemos usar esse tipo como qualquer outro tipo de dados, e as constantes nomeadas facilitam o uso e a legibilidade do c√≥digo:

      ```csharp
      DiaDaSemana dia = DiaDaSemana.Segunda;
      Console.WriteLine("Hoje √© " + dia); // Sa√≠da: Hoje √© Segunda
      ```
    
    * Os tipos ordinais definidos pelo usu√°rio s√£o uma forma conveniente e segura de representar um conjunto limitado de valores em C#, e eles ajudam a tornar o c√≥digo mais leg√≠vel e autodocumentado.

  * **Arrays:**

    * Tipos:

      * **Array est√°tico:** Um array est√°tico em C# √© uma cole√ß√£o de elementos do mesmo tipo com tamanho fixo, onde o tamanho precisa ser definido em tempo de compila√ß√£o e n√£o pode ser alterado durante a execu√ß√£o do programa.

        ```csharp
          int[] staticArray = new int[5]; // Cria um array est√°tico de inteiros com tamanho 5.
        ```

      * **Array heap-din√¢mico:** Em C#, os arrays s√£o alocados no heap (mem√≥ria gerenciada) e o tamanho do array pode ser definido em tempo de execu√ß√£o usando o construtor new.

        ```csharp
          int size = 3;
          int[] dynamicArray = new int[size]; // Cria um array din√¢mico de inteiros com tamanho definido em tempo de execu√ß√£o.
        ```

    * Inicializa√ß√£o:

      * **Inicializa√ß√£o direta:** voc√™ pode inicializar um array diretamente com os valores dos elementos entre chaves {}.
        ```csharp
        int[] numbers = { 1, 2, 3, 4, 5 };
        ```

      * **Usando o construtor new:** voc√™ pode usar o construtor new para criar um array e definir o tamanho explicitamente.
        ```csharp
        int[] dynamicArray = new int[3]; // Cria um array de inteiros com tamanho 3.
        ```      
      
      * **Inicializa√ß√£o com valores padr√£o:** um array √© automaticamente preenchido com valores padr√£o (zero, no caso de inteiros) se voc√™ n√£o definir valores para todos os elementos.
        ```csharp
        int[] uninitializedArray = new int[5]; // Todos os elementos ser√£o 0.
        ```      
      
      * **Inicializa√ß√£o com valor √∫nico:** voc√™ pode inicializar todos os elementos do array com o mesmo valor usando Enumerable.Repeat().
        ```csharp
        int[] repeatedArray = Enumerable.Repeat(10, 5).ToArray(); // Cria um array com 5 elementos, todos com valor 10.
        ```
      
      * **Inicializa√ß√£o com array existente:** voc√™ pode inicializar um novo array com os elementos de um outro array j√° existente.
        ```csharp
        int[] sourceArray = { 1, 2, 3 };
        int[] newArray = new int[sourceArray.Length];
        Array.Copy(sourceArray, newArray, sourceArray.Length);
        ```
      
      * **Array multidimensional:** al√©m de arrays unidimensionais, voc√™ pode criar arrays multidimensionais (matrizes).
        ```csharp
        int[,] matrix = { { 1, 2 }, { 3, 4 } }; // Cria uma matriz 2x2.
        ```

      * **Array de arrays (jagged arrays):** voc√™ pode criar arrays que cont√™m outros arrays.
        ```csharp
        int[][] jaggedArray = new int[3][];
        jaggedArray[0] = new int[] { 1, 2 };
        jaggedArray[1] = new int[] { 3, 4, 5 };
        jaggedArray[2] = new int[] { 6 };
        ```
    
    * Implementa√ß√£o:

      * **Tipo Base:**  
        * Em C#, todos os tipos de arrays s√£o derivados da classe base System.Array. Isso inclui arrays unidimensionais, multidimensionais e arrays de arrays (jagged arrays).

      * **Aloca√ß√£o de Mem√≥ria:**
        * Quando voc√™ cria um array usando o operador new, a mem√≥ria √© alocada no heap (mem√≥ria gerenciada). Isso √© verdade mesmo para arrays primitivos, pois o C# trata todos os tipos como objetos.
        * A mem√≥ria alocada √© cont√≠gua e igual ao tamanho do array multiplicado pelo tamanho do tipo de elemento.

      * **Acesso aos Elementos:**
        * Os elementos de um array s√£o acessados usando √≠ndices baseados em zero. Por exemplo, array[0] acessa o primeiro elemento do array.
        * O acesso direto aos elementos √© r√°pido, pois os arrays mant√™m informa√ß√µes sobre o tipo de elemento e a localiza√ß√£o na mem√≥ria, o que permite calcular rapidamente a posi√ß√£o do elemento.

      * **Tamanho Fixo:**
        * Os arrays em C# t√™m tamanho fixo, o que significa que voc√™ precisa definir o tamanho do array no momento da cria√ß√£o e n√£o pode alter√°-lo posteriormente.
        * Se voc√™ precisar de uma cole√ß√£o din√¢mica, pode usar outras estruturas de dados como listas (List<T>) ou cole√ß√µes gen√©ricas.

      * **Performance:**
        * Os arrays oferecem acesso r√°pido aos elementos, pois eles est√£o armazenados em mem√≥ria cont√≠gua, permitindo um acesso direto e eficiente aos endere√ßos de mem√≥ria.
        * A busca e a modifica√ß√£o de elementos em arrays s√£o opera√ß√µes O(1) (constante), desde que o √≠ndice seja conhecido.
        
      * **Comprimento do Array:**
        * O comprimento de um array (n√∫mero de elementos) √© armazenado como uma propriedade chamada Length. Essa propriedade √© usada para iterar pelos elementos de um array.
      
      * **Limita√ß√µes:**
        * Os arrays t√™m limita√ß√µes, como tamanho fixo e inefici√™ncia na inser√ß√£o/remo√ß√£o de elementos. Para casos onde a flexibilidade √© mais importante, outras estruturas de dados, como listas, podem ser mais adequadas.

      * **Array Multidimensional e Jagged Arrays:**
        * Arrays multidimensionais (matrizes) s√£o implementados como arrays de arrays. Cada elemento do array principal cont√©m um sub-array.
        * Jagged arrays (arrays de arrays) s√£o arrays onde cada elemento √© um array separado. Eles podem ter comprimentos diferentes para cada sub-array.

  * **Registro:**

    * Um registro em C# √© uma classe ou um struct que fornece sintaxe e comportamento especiais para trabalhar com modelos de dados. O modificador `record` instrui o compilador a sintetizar membros que s√£o √∫teis para tipos cuja fun√ß√£o prim√°ria √© armazenar dados. Esses membros incluem uma sobrecarga de ToString() e membros que d√£o suporte √† igualdade de valor.

    * Considere usar um registro no lugar de uma classe ou struct nos seguintes cen√°rios:

      * Voc√™ deseja definir um modelo de dados que depende da igualdade de valor.
      * Voc√™ deseja definir um tipo para o qual os objetos s√£o imut√°veis.

    * Igualdade de valor:

      * Para registros, a igualdade de valor significa que duas vari√°veis de um tipo de registro s√£o iguais se os tipos corresponderem e todos os valores de propriedade e de campo corresponderem. Para outros tipos de refer√™ncia, como classes, igualdade significa igualdade de refer√™ncia. Ou seja, duas vari√°veis de um tipo de classe s√£o iguais quando se referem ao mesmo objeto. M√©todos e operadores que determinam a igualdade de duas inst√¢ncias de registro usam igualdade de valor.

    * Imutabilidade: 

      * Um tipo imut√°vel √© aquele que impede que voc√™ altere qualquer propriedade ou valor de campo de um objeto ap√≥s ser instanciado. A imutabilidade pode ser √∫til quando voc√™ precisa que um tipo seja thread-safe ou que um c√≥digo hash permane√ßa o mesmo em uma tabela de hash. Os registros fornecem sintaxe concisa para criar e trabalhar com tipos imut√°veis.
    
    * Diferen√ßas: 

      * A mesma sintaxe que declara e instancia classes ou structs pode ser usada com registros. Basta substituir a palavra-chave `class` por `record`, ou usar `record struct` em vez de `struct`. Da mesma forma, as classes de registro d√£o suporte √† mesma sintaxe para expressar rela√ß√µes de heran√ßa. Os registros diferem das classes das seguintes maneiras:

        * Voc√™ pode usar par√¢metros posicionais em um construtor prim√°rio para criar e instanciar um tipo com propriedades imut√°veis.
        * Os mesmos m√©todos e operadores que indicam igualdade de refer√™ncia ou desigualdade em classes (como Object.Equals(Object) e `==`), indicam igualdade de valor ou desigualdade nos registros.
        * Voc√™ pode usar uma express√£o with para criar uma c√≥pia de um objeto imut√°vel com novos valores em propriedades selecionadas.
        * O m√©todo `ToString` de um registro cria uma cadeia de caracteres formatada que mostra o nome do tipo de um objeto e os nomes e valores de todas as propriedades p√∫blicas dele.
        * Um registro pode herdar de outro registro. Um registro n√£o pode herdar de uma classe, e uma classe n√£o pode herdar de um registro.
      
      * Os structs de registro diferem dos structs, pois o compilador sintetiza os m√©todos de igualdade e `ToString`. O compilador sintetiza o m√©todo `Deconstruct` para structs de registro posicional.

      * O compilador sintetiza uma propriedade public init-only para cada par√¢metro de construtor prim√°rio em um `record class`. Em um `record struct`, o compilador sintetiza uma propriedade p√∫blica de leitura/grava√ß√£o. O compilador n√£o cria propriedades para par√¢metros de construtor prim√°rio em tipos `class` e `struct` que n√£o incluem modificador `record`.

      * Exemplos:

        O exemplo a seguir define um registro p√∫blico que usa par√¢metros posicionais para declarar e instanciar um registro. Em seguida, ele imprime o nome do tipo e os valores de propriedade:
          ```csharp
          public record Person(string FirstName, string LastName);

          public static void Main()
          {
              Person person = new("Nancy", "Davolio");
              Console.WriteLine(person);
              // sa√≠da: Person { FirstName = Nancy, LastName = Davolio }
          }
          ```
        
        O seguinte exemplo demonstra a igualdade de valor em registros:
          ```csharp
          public record Person(string FirstName, string LastName, string[] PhoneNumbers);

          public static void Main()
          {
              var phoneNumbers = new string[2];
              Person person1 = new("Nancy", "Davolio", phoneNumbers);
              Person person2 = new("Nancy", "Davolio", phoneNumbers);
              Console.WriteLine(person1 == person2); // sa√≠da: Verdadeiro

              person1.PhoneNumbers[0] = "555-1234";
              Console.WriteLine(person1 == person2); // sa√≠da: Verdadeiro

              Console.WriteLine(ReferenceEquals(person1, person2)); // sa√≠da: Falso
          }
          ```

  * **Ponteiro:**

    * Unsafe: 

      * A maior parte do c√≥digo C# que voc√™ escreve √© "c√≥digo seguro verific√°vel". C√≥digo seguro verific√°vel significa que as ferramentas do .NET podem confirmar que o c√≥digo √© seguro. Em geral, o c√≥digo seguro n√£o acessa diretamente a mem√≥ria usando ponteiros. Ele tamb√©m n√£o aloca mem√≥ria bruta. Em vez disso, ele cria objetos gerenciados.

      * O C# d√° suporte a um contexto unsafe em que voc√™ pode escrever c√≥digos n√£o verific√°veis. Em um contexto `unsafe`, o c√≥digo pode usar ponteiros, alocar e liberar blocos de mem√≥ria e chamar m√©todos usando ponteiros de fun√ß√£o. O c√≥digo n√£o seguro em C# n√£o √© necessariamente perigoso; √© apenas um c√≥digo cuja seguran√ßa n√£o pode ser verificada.

      * O c√≥digo n√£o seguro tem as propriedades a seguir:

        * Blocos de c√≥digo, tipos e m√©todos podem ser definidos como n√£o seguros;
        * Em alguns casos, o c√≥digo n√£o seguro pode aumentar o desempenho de um aplicativo removendo as verifica√ß√µes de limites de matriz;
        * O c√≥digo n√£o seguro √© necess√°rio quando voc√™ chama fun√ß√µes nativas que exigem ponteiros;
        * Usar o c√≥digo n√£o seguro apresenta riscos de seguran√ßa e estabilidade;
        * O c√≥digo que cont√©m blocos n√£o seguros deve ser compilado com a op√ß√£o do compilador AllowUnsafeBlocks.

    * Tipos de Ponteiro:

      * Em um contexto n√£o seguro, os tipos podem ser de ponteiro, al√©m de tipo de valor ou tipo de refer√™ncia. Uma declara√ß√£o de tipo de ponteiro usa uma das seguintes formas:
        ```csharp
        type* identifier;
        void* identifier; //permitido, mas n√£o recomendado
        ```

      * O tipo especificado antes do `*` em um tipo de ponteiro √© chamado de tipo *referent*. Somente um tipo n√£o gerenciado pode ser um tipo referent.

      * Os tipos de ponteiro n√£o s√£o herdados de object e n√£o h√° convers√£o entre tipos de ponteiro e `object`. Al√©m disso, as convers√µes boxing e unboxing n√£o oferecem suporte a ponteiros. No entanto, voc√™ pode converter entre diferentes tipos de ponteiro e tipos de ponteiro e tipos integrais.

      * Ao declarar v√°rios ponteiros na mesma declara√ß√£o, voc√™ escreve o asterisco (`*`) juntamente com o tipo subjacente apenas. Ele n√£o √© usado como um prefixo para cada nome de ponteiro. Por exemplo:
        ```csharp
        int* p1, p2, p3;   // Ok
        int *p1, *p2, *p3;   // Inv√°lido em C#
        ```
      
      * Um ponteiro n√£o pode apontar para uma refer√™ncia ou um struct que contenha refer√™ncias, pois uma refer√™ncia de objeto pode ser coletada como lixo mesmo se um ponteiro estiver apontando para ela. O coletor de lixo n√£o se d√° conta de que um objeto est√° sendo apontado por qualquer tipo de ponteiro.

      * O valor da vari√°vel de ponteiro do tipo `MyType*` √© o endere√ßo de uma vari√°vel do tipo `MyType`. Estes s√£o exemplos de declara√ß√µes de tipos de ponteiro:

        * `int* p`: p √© um ponteiro para um inteiro.  
        * `int** p`: p √© um ponteiro para um ponteiro para um inteiro.
        * `int*[] p`: p √© uma matriz unidimensional de ponteiros para inteiros.
        * `char* p`: p √© um ponteiro para um caractere.
        * `void* p`: p √© um ponteiro para um tipo desconhecido.

      * O operador de indire√ß√£o de ponteiro * pode ser usado para acessar o conte√∫do no local apontado pela vari√°vel de ponteiro. Por exemplo, considere a seguinte declara√ß√£o:

        ```csharp
        int* myVariable;
        ```

      * A express√£o *myVariable denota a vari√°vel int encontrada no endere√ßo contido em myVariable.
    
    
    * Opera√ß√µes:

      * Em C# √© poss√≠vel realizar as seguintes a√ß√µes com ponteiros:

        * **Declara√ß√£o de Ponteiro:**

          Voc√™ pode declarar um ponteiro usando o tipo do valor que ele aponta, seguido pelo operador `*`.

        * **Atribui√ß√£o de Endere√ßo:**

          Voc√™ pode atribuir um endere√ßo de mem√≥ria a um ponteiro usando o operador de refer√™ncia `&`.

        * **Desreferenciamento:**
        
          Para acessar o valor apontado por um ponteiro, voc√™ usa o operador de desreferenciamento `*`.

        * **Atribui√ß√£o de Valor:**

          Voc√™ pode atribuir um valor a um endere√ßo apontado por um ponteiro.

        * **Aritm√©tica de Ponteiro:**

          Em C#, a aritm√©tica de ponteiro √© restrita a adi√ß√£o e subtra√ß√£o de valores inteiros constantes.

        * **Compara√ß√£o de Ponteiro:**

          Voc√™ pode comparar ponteiros usando os operadores de compara√ß√£o (==, !=, <, <=, >, >=).

        * **Uso com Arrays:**

          Ponteiros podem ser usados para percorrer arrays.

    * Operadores:

      | Operador/Instru√ß√£o  |  Uso  |
      | ----------- | ----------- |
      |`*`  | Executa indire√ß√£o de ponteiro|
      |`->` | Acessa um membro de um struct atrav√©s de um ponteiro|
      |`[]` | Indexa um ponteiro|
      |`&`  | Obt√©m o endere√ßo de uma vari√°vel|
      |`++` e `--`  | Incrementa e decrementa ponteiros|
      |`+` e `-`  | Executa aritm√©tica de ponteiros|
      |`==`, `!=`, `<`, `>`, `<=` e `>=`  | Compara ponteiros|
      |_stackalloc_ | Aloca mem√≥ria na pilha|
      |_fixedinstru√ß√£o_ | Corrige temporariamente uma vari√°vel para que seu endere√ßo possa ser encontrado|

  * Verifica√ß√£o de Tipo:

    * C# √© uma linguagem de programa√ß√£o que faz verifica√ß√£o de tipo em tempo de compila√ß√£o e em tempo de execu√ß√£o para garantir a seguran√ßa e a integridade do programa. Aqui est√£o as principais informa√ß√µes sobre a verifica√ß√£o de tipo em C#:

    * Verifica√ß√£o de Tipo em Tempo de Compila√ß√£o:

      * Durante o processo de compila√ß√£o, o compilador C# verifica se as opera√ß√µes e atribui√ß√µes est√£o sendo feitas com tipos compat√≠veis. Ele garante que voc√™ n√£o esteja tentando fazer opera√ß√µes inv√°lidas, como adicionar um n√∫mero a uma string ou atribuir um tipo incompat√≠vel a uma vari√°vel. Isso ajuda a detectar erros de tipo antes mesmo de executar o programa.

    * Verifica√ß√£o de Tipo em Tempo de Execu√ß√£o:

      * Al√©m da verifica√ß√£o em tempo de compila√ß√£o, C# tamb√©m faz verifica√ß√µes de tipo em tempo de execu√ß√£o. Isso √© especialmente relevante quando se trabalha com polimorfismo, heran√ßa e tipos din√¢micos. Durante a execu√ß√£o, o Common Language Runtime (CLR) do .NET verifica se as chamadas de m√©todo e as opera√ß√µes de tipo s√£o v√°lidas, evitando erros e exce√ß√µes relacionados a tipos incompat√≠veis.

    * Verifica√ß√£o de Tipo para Seguran√ßa:

      * A verifica√ß√£o de tipo em C# tamb√©m desempenha um papel fundamental na seguran√ßa. A linguagem √© projetada para prevenir opera√ß√µes inseguras que poderiam levar a problemas de acesso √† mem√≥ria ou corrup√ß√£o de dados. Isso √© especialmente importante para prevenir vulnerabilidades como buffer overflows e vazamentos de mem√≥ria.

  * Tipagem Forte (Strong Typing):

    * A tipagem forte em C# significa que os tipos de dados s√£o rigorosamente aplicados e verificados durante o desenvolvimento e a execu√ß√£o do programa. Isso implica que opera√ß√µes inv√°lidas entre tipos diferentes n√£o s√£o permitidas, e todas as convers√µes de tipo devem ser feitas explicitamente. Essa abordagem ajuda a prevenir erros de tipo e promove a seguran√ßa e integridade do c√≥digo.

##  :triangular_ruler: Express√µes e Senten√ßas de Atribui√ß√£o

  * Operadores: 

    * **Operadores Un√°rios:** operam em um √∫nico operando.
      * Exemplos:

        * `+` (positivo)
        * `-` (negativo)
        * `!` (nega√ß√£o l√≥gica)
        * `~` (complemento bit a bit)
        * `++` (incremento)
        * `--` (decremento)

    * **Operadores Bin√°rios:** operam em dois operandos.
      * Exemplos:

        * `+` (adi√ß√£o)
        * `-` (subtra√ß√£o)
        * `*` (multiplica√ß√£o)
        * `/` (divis√£o)
        * `%` (m√≥dulo)
        * `==` (igual a)
        * `!=` (diferente de)
        * `<` (menor que)
        * `>` (maior que)
        * `<=` (menor ou igual a)
        * `>=` (maior ou igual a)
        * `&` (AND bit a bit)
        * `|` (OR bit a bit)
        * `^` (XOR bit a bit)
        * `&&` (AND l√≥gico)
        * `||` (OR l√≥gico)
        * `<<` (deslocamento de bits √† esquerda)
        * `>>` (deslocamento de bits √† direita)

    * **Operador Tern√°rio:** s√≥ existe um operador tern√°rio em C# e ele √© usado para criar express√µes condicionais.
      * Exemplo:

        * `?` : (operador condicional tern√°rio)

  * Preced√™ncia:

    * A preced√™ncia de operadores em C# determina a ordem em que as opera√ß√µes s√£o avaliadas em uma express√£o. √â importante entender a preced√™ncia dos operadores para garantir que as express√µes sejam avaliadas da maneira correta. Aqui est√° uma lista dos operadores em C# ordenados por preced√™ncia, do mais alto ao mais baixo:

      | Operador |  Significado  |
      | ----------- | ----------- |
      | `()`, `[]`, `->`, `.` | Acesso a membros|
      | `++`, `--` | Incremento e Decremento|
      | `+`, `-` | Operadores un√°rios de sinal|
      | `!`, `~` | Operadores de nega√ß√£o|
      | `*`, `/`, `%` | Multiplica√ß√£o, Divis√£o, M√≥dulo|
      | `+`, `-` | Adi√ß√£o, Subtra√ß√£o|
      | `<<`, `>>` | Deslocamento de bits|
      | `<`, `<=`, `>`, `>=` | Operadores de compara√ß√£o|
      | `==`, `!=` | Igualdade e Desigualdade|
      | `&` | AND Bitwise|
      | `^` | XOR Bitwise|
      | `\|` | OR Bitwise|
      | `&&` | AND L√≥gico|
      | `\|\|` | OR L√≥gico|
      | `? :` | Operador condicional tern√°rio|
      | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `\|=`, `^=`, `<<=`, `>>=` | Atribui√ß√£o|
      | `,` | Operador de v√≠rgula, usado para separar express√µes|